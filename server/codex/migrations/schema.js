/**
 * Initializes elasticsearch with our schema. Kind of like Rails's schema.rb, but not autogenerated.
 */
'use strict';

var elasticsearch = require('elasticsearch');
var Promise = require('bluebird');
var _ = require('lodash');
var conf = require('../../conf/index');
var logger = conf.logger;

// don't use shared connection
var client = new elasticsearch.Client(_.clone(conf.elasticsearch));

// List of requests to make to elasticsearch. Note to future maintainers: try to keep this sorted alphabetically
var indexRequests = [
  function diagnosis (callback) {
    client.indices.create({
      // TODO timestamp index name and create alias
      index: 'diagnosis', // don't use model b/c that's kind of a circular dependency (and not what Rails does)
      body: {
        mappings: {
          diagnosis: {
            properties: {
              name: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              phoneId: {
                type: 'string',
                index: 'not_analyzed'
              }
            }
          }
        }
      }
    }, callback);
  },

  function district (callback) {
    client.indices.create({
      index: 'region', // not 'district' so that other geographic units can be tracked, hopefully we don't regret this
      body: {
        mappings: {
          district: {
            properties: {
              name: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              phoneId: {
                type: 'string',
                index: 'not_analyzed'
              }
            }
          }
        }
      }
    }, callback);
  },

  function outpatient (callback) {
    client.indices.create({
      index: 'outpatient',
      body: {
        settings: {
          analysis: {
            analyzer: {
              // allow searching on sex=female or sex=f
              sex: {
                tokenizer: 'whitespace',
                filter: ['lowercase', 'sex']
              }
            },
            filter: {
              sex: {
                type: 'synonym',
                synonyms: [
                  'm => male',
                  'f => female'
                ]
              }
            }
          }
        },
        mappings: {
          visit: {
            properties: {
              reportDate: {
                type: 'date'
              },

              // AKA presenting problem, Reason for Encounter, Reason for Presenting, etc. Free text
              chiefComplaint: {
                type: 'string'
              },

              // Array of well-known symptoms that the patient presented with. Might be populated by parsing
              // chiefComplaint, or might be used instead of chiefComplaint. Used for syndromic surveillance.
              symptoms: {
                type: 'string'
              },

              // Array of well-known diagnoses. Usually used with symptoms.
              diagnoses: {
                type: 'string'
              },

              // Array of diseases that warrant reporting. Typically used instead of symptoms.
              notifiableDiseases: {
                type: 'string'
              },

              patient: {
                properties: {
                  _id: {
                    type: 'integer',
                    index: 'not_analyzed'
                  },
                  age: {
                    // we don't need that much precision, but we do want to support fractional ages, e.g. 0.5
                    type: 'double'
                  },
                  sex: {
                    type: 'string',
                    analyzer: 'sex'
                  },
                  weight: {
                    // Note that we do not store units, e.g. lb or kg. It's up to the application to make sure every
                    // entry uses the same units.
                    type: 'double'
                  },

                  // TODO move all this under vitals? could be useful if we split it out as separate addon
                  temperature: {
                    type: 'double'
                  },
                  pulse: {
                    type: 'double'
                  },
                  bloodPressure: {
                    properties: {
                      diastolic: {
                        type: 'double'
                      },
                      systolic: {
                        type: 'double'
                      }
                    }
                  }
                }
              },

              // AKA the clinic, hospital, military treatment center, etc. where the patient was processed.
              // Why medicalFacility? Because that's what http://en.wikipedia.org/wiki/Medical_facility says.
              medicalFacility: {
                properties: {

                  // The name of this facility
                  name: {
                    type: 'string'
                  },

                  // The administrative subdivision of this facility. Could be state, county, school district, etc.
                  district: {
                    type: 'string',
                    fields: {
                      raw: {
                        type: 'string',
                        index: 'not_analyzed'
                      }
                    }
                  }
                }
              },

              audit: {
                properties: {
                  // TODO delete and just have modifications[0] be creationDate
                  // when the record was added to the system
                  creation: {
                    properties: {
                      // Date record was created
                      date: {
                        type: 'date'
                      },

                      // User that created this record
                      user: {
                        type: 'string' // no need to store whole user object here
                      }
                    }
                  },

                  // Array of modifications to this record
                  modifications: {
                    properties: {
                      // date of modification
                      date: {
                        type: 'date'
                      },

                      // user ID that did the modifying
                      user: {
                        type: 'string' // no need to store whole user object here
                      }

                      // could also store _source to track changes, but that's a lot of extra storage
                    }
                  }
                }
              }
            }
          }
        }
      }
    }, callback);
  },

  function symptom (callback) {
    client.indices.create({
      index: 'symptom',
      body: {
        mappings: {
          symptom: {
            properties: {
              name: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              phoneId: {
                type: 'string',
                index: 'not_analyzed'
              }
            }
          }
        }
      }
    }, callback);
  },

  function user (callback) {
    client.indices.create({
      index: 'user',
      body: {
        mappings: {
          user: {
            properties: {
              username: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              email: {
                type: 'string',
                index: 'not_analyzed'
              },
              password: {
                type: 'string',
                index: 'not_analyzed'
              },
              firstName: {
                type: 'string',
                index: 'not_analyzed'
              },
              lastName: {
                type: 'string',
                index: 'not_analyzed'
              },
              disabled: {
                type: 'boolean'
              },
              roles: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              districts: {
                type: 'string',
                fields: {
                  raw: {
                    type: 'string',
                    index: 'not_analyzed'
                  }
                }
              },
              audit: {
                properties: {
                  // when the record was added to the system
                  creation: {
                    properties: {
                      // Date record was created
                      date: {
                        type: 'date'
                      },
                      // User that created this record
                      user: {
                        type: 'string' // no need to store whole user object here
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }, callback);
  }
];

Promise.settle(indexRequests.map(function (ir) {
    return Promise.promisify(ir)();
  }))
  .then(function (promiseInspections) {
    var errors = promiseInspections.filter(function (pi) {
      return pi.isRejected();
    }).map(function (pi) {
      return pi.error();
    });

    errors.forEach(function (e) {
      logger.error({err: e}, 'Error creating index');
    });

    var numSuccesses = indexRequests.length - errors.length;
    logger.info('Successfully created %d out of %d indices (%d errors)', numSuccesses, indexRequests.length,
      errors.length);
  })
  .catch(function (e) {
    // this shouldn't ever happen, but in case it does we don't want to swallow errors
    logger.error({err: e}, 'Error creating indices');
  })
  .finally(function () {
    client.close();
  });
